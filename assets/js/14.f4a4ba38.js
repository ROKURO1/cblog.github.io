(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{499:function(t,r,e){"use strict";e.r(r);var a=e(4),n=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),e("h3",{attrs:{id:"算法思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法思路"}},[t._v("#")]),t._v(" 算法思路")]),t._v(" "),e("p",[t._v("把题目的要求细化，搞清楚"),e("strong",[t._v("根节点")]),t._v("应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了")]),t._v(" "),e("h3",{attrs:{id:"如何判断前中后序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何判断前中后序"}},[t._v("#")]),t._v(" 如何判断前中后序")]),t._v(" "),e("p",[t._v("根据题意，思考一个二叉树节点需要做什么")]),t._v(" "),e("ul",[e("li",[t._v("前序：对称的二叉树")]),t._v(" "),e("li",[t._v("中序：")]),t._v(" "),e("li",[t._v("后序：【先对左右子树的节点】计算二叉树有多少个节点、652寻找重复子树")])]),t._v(" "),e("h2",{attrs:{id:"二叉搜索树bst"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树bst"}},[t._v("#")]),t._v(" 二叉搜索树BST")]),t._v(" "),e("h3",{attrs:{id:"bst特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bst特性"}},[t._v("#")]),t._v(" BST特性")]),t._v(" "),e("ol",[e("li",[t._v("对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。")]),t._v(" "),e("li",[t._v("对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST。")]),t._v(" "),e("li",[t._v("BST 的中序遍历结果是升序的。")])]),t._v(" "),e("h3",{attrs:{id:"例题-leetcode230-寻找第-k-小的元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例题-leetcode230-寻找第-k-小的元素"}},[t._v("#")]),t._v(" 例题 leetcode230 寻找第 K 小的元素")]),t._v(" "),e("p",[t._v("一个直接的思路就是升序排序，然后找第 k 个元素呗。BST 的中序遍历其实就是升序排序的结果，找第 k 个元素肯定不是什么难事。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int kthSmallest(TreeNode root, int k) {\n    // 利用 BST 的中序遍历特性\n    traverse(root, k);\n    return res;\n}\n\n// 记录结果\nint res = 0;\n// 记录当前元素的排名\nint rank = 0;\nvoid traverse(TreeNode root, int k) {\n    if (root == null) {\n        return;\n    }\n    traverse(root.left, k);\n    /* 中序遍历代码位置 */\n    rank++;\n    if (k == rank) {\n        // 找到第 k 小的元素\n        res = root.val;\n        return;\n    }\n    /*****************/\n    traverse(root.right, k);\n}\n")])])]),e("p",[t._v("要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 O(logN) 的复杂度，让你算一个第 k 小元素，时间复杂度竟然要 O(N)，有点低效了。"),e("br"),t._v("\n我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST 的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。")])])}),[],!1,null,null,null);r.default=n.exports}}]);