(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{509:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一-作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-作用域"}},[t._v("#")]),t._v(" 一 作用域")]),t._v(" "),s("p",[t._v("可访问变量的集合")]),t._v(" "),s("h3",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),s("ol",[s("li",[t._v("全局作用域")]),t._v(" "),s("li",[t._v("函数作用域")]),t._v(" "),s("li",[t._v("块级作用域")])]),t._v(" "),s("h3",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。")]),t._v(" "),s("h3",{attrs:{id:"函数作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[t._v("#")]),t._v(" 函数作用域")]),t._v(" "),s("p",[t._v("函数的作用域在函数定义的时候就决定了"),s("br"),t._v("\n这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！")]),t._v(" "),s("h3",{attrs:{id:"js是静态作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js是静态作用域"}},[t._v("#")]),t._v(" js是静态作用域")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var value = 1;\n\nfunction foo() {\n    console.log(value);\n}\n\nfunction bar() {\n    var value = 2;\n    foo();\n}\n\nbar();\n")])])]),s("p",[t._v("结果是 1，因为函数的作用域在函数定义的时候就决定了，按照作用域链foo()中没有value则去父级作用域找")]),t._v(" "),s("h2",{attrs:{id:"二-执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-执行上下文"}},[t._v("#")]),t._v(" 二 执行上下文")]),t._v(" "),s("p",[t._v("定义：js代码运行环境"),s("br"),t._v("\n分类：全局执行上下文，函数上下文，eval上下文")]),t._v(" "),s("h4",{attrs:{id:"执行栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行栈"}},[t._v("#")]),t._v(" 执行栈")]),t._v(" "),s("p",[t._v("执行栈用于存储代码执行期间创建的所有上下文")]),t._v(" "),s("h2",{attrs:{id:"三-this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三-this"}},[t._v("#")]),t._v(" 三 this")]),t._v(" "),s("ol",[s("li",[t._v("默认绑定：函数调用时无任何调用前缀的情景，指向全局对象")]),t._v(" "),s("li",[t._v("隐式绑定：指向调用函数的那个对象"),s("br"),t._v("\n如果存在多个对象，this指向距离调用自己最近的对象\n"),s("h4",{attrs:{id:"隐式丢失-this指向window的情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隐式丢失-this指向window的情况"}},[t._v("#")]),t._v(" 隐式丢失（this指向window的情况）")]),t._v(" "),s("ol",[s("li",[t._v("参数传递")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function fn1(param) {\n    param();\n};\nfn1(obj.fn);\n")])])]),t._v("2)变量赋值"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(" let fn1 = obj.fn;\n fn1(); \n")])])])]),t._v(" "),s("li",[t._v("显式绑定：通过call、apply以及bind"),s("br"),t._v("\n【注意】bind多次执行，函数this还是指向第一次bind的对象。因为bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改")]),t._v(" "),s("li",[t._v("new")]),t._v(" "),s("li",[t._v("箭头函数的this:等于它上层上下文中的this")])]),t._v(" "),s("h2",{attrs:{id:"四-闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四-闭包"}},[t._v("#")]),t._v(" 四 闭包")]),t._v(" "),s("ol",[s("li",[t._v("解释：一个可以访问外部作用域的内部函数。")]),t._v(" "),s("li",[t._v("在本质上，闭包是将函数内部和函数外部连接起来的桥梁。")]),t._v(" "),s("li",[t._v("闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了为什么闭包还能引用到函数内的变量。")])]),t._v(" "),s("h2",{attrs:{id:"五-原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五-原型"}},[t._v("#")]),t._v(" 五 原型")]),t._v(" "),s("ul",[s("li",[t._v("每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.")]),t._v(" "),s("li",[t._v("如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.")])]),t._v(" "),s("h3",{attrs:{id:"原型链的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型链的问题"}},[t._v("#")]),t._v(" 原型链的问题")]),t._v(" "),s("ul",[s("li",[t._v("问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;")]),t._v(" "),s("li",[t._v("问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数.")])]),t._v(" "),s("h2",{attrs:{id:"六-继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六-继承"}},[t._v("#")]),t._v(" 六 继承")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://louiszhai.github.io/2015/12/15/prototypeChain/",target:"_blank",rel:"noopener noreferrer"}},[t._v("🔗链接"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"_1-原型链继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-原型链继承"}},[t._v("#")]),t._v(" 1. 原型链继承")]),t._v(" "),s("p",[s("strong",[t._v("原理：让新实例的原型等于父类的实例")]),t._v(" "),s("code",[t._v("Child.prototype = new Father()")])]),t._v(" "),s("h4",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("p",[t._v("实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）")]),t._v(" "),s("h4",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),s("ol",[s("li",[t._v("新实例无法向父类构造函数传参。")]),t._v(" "),s("li",[t._v("继承单一。")]),t._v(" "),s("li",[t._v("所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）")])]),t._v(" "),s("h3",{attrs:{id:"_2-构造函数继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-构造函数继承"}},[t._v("#")]),t._v(" 2. 构造函数继承")]),t._v(" "),s("p",[s("strong",[t._v("原理: 在子类构造函数中使用父类构造函数+call()。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function Child（）{\n    Father.call(this.name)\n}\n")])])]),s("h4",{attrs:{id:"特点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("ol",[s("li",[t._v("只继承了父类构造函数的属性，没有继承父类原型的属性。")]),t._v(" "),s("li",[t._v("可以继承多个构造函数属性（call多个）。")])]),t._v(" "),s("h4",{attrs:{id:"缺点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),s("p",[t._v("不能继承父类原型的属性")]),t._v(" "),s("h3",{attrs:{id:"_3-组合继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-组合继承"}},[t._v("#")]),t._v(" 3. 组合继承")]),t._v(" "),s("h4",{attrs:{id:"特点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-3"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("p",[t._v("结合了两种模式的优点，传参和复用")]),t._v(" "),s("h4",{attrs:{id:"缺点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-3"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),s("p",[t._v("调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。")]),t._v(" "),s("h3",{attrs:{id:"_4-原型式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-原型式继承"}},[t._v("#")]),t._v(" 4. 原型式继承")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function content（obj){\n    function Child(){} //声明子类的构造函数\n    Child.prototype = obj \n    return new Child()  //    返回实例\n}\nlet father = new Father();\nlet child = content(father)\n")])])]),s("p",[s("strong",[t._v("原理：在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例。【浅复制】object.create()就是这个原理。")])]),t._v(" "),s("h4",{attrs:{id:"特点-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点-4"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),s("p",[t._v("类似于复制一个对象，用函数来包装")]),t._v(" "),s("h4",{attrs:{id:"缺点-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-4"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),s("h3",{attrs:{id:"_5-寄生式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-寄生式继承"}},[t._v("#")]),t._v(" 5. 寄生式继承")]),t._v(" "),s("p",[s("strong",[t._v("原理：就是给原型式继承外面套了个壳子。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function content（obj){\n    function Child(){} //声明子类的构造函数\n    Child.prototype = obj \n    return new Child()  //    返回实例\n}\nlet father = new Father();\nfunction subobject（obj){\n    let child = content(father)\n    child.name = 'cb'\n    return child\n}\nlet child1 = subobject(father)\n")])])]),s("h4",{attrs:{id:"缺点-没用到原型-无法复用。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点-没用到原型-无法复用。"}},[t._v("#")]),t._v(" 缺点：没用到原型，无法复用。")]),t._v(" "),s("h3",{attrs:{id:"_6-寄生组合式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-寄生组合式继承"}},[t._v("#")]),t._v(" 6. 寄生组合式继承")]),t._v(" "),s("hr"),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function content（obj){\n    function Child(){} \n    Child.prototype = obj \n    return new Child() \n}\nlet con = content(Father.prototype); //继承原型属性\n\nfunction Sub（){\n    Father.call(this)//继承父类构造函数属性\n}\n//重点\nSub.prototype = con //继承con的实例\ncon.constructor = Sub\nlet child1 = new Sub()\n")])])]),s("h3",{attrs:{id:"_7-class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-class"}},[t._v("#")]),t._v(" 7. Class")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class father{}\n\nclass son extends father{\n    Constructor{\n        super(继承父类的属性)\n    }\n}\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);