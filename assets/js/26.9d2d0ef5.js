(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{512:function(r,e,a){"use strict";a.r(e);var t=a(4),s=Object(t.a)({},(function(){var r=this,e=r.$createElement,a=r._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"web-worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[r._v("#")]),r._v(" Web Worker")]),r._v(" "),a("p",[a("strong",[r._v("Web Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。")])]),r._v(" "),a("h2",{attrs:{id:"快速上手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速上手"}},[r._v("#")]),r._v(" 快速上手")]),r._v(" "),a("p",[r._v("只需调用Worker() 构造函数并传入一个要在 worker 线程内运行的脚本的URI，即可创建一个新的worker。")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v('var myWorker = new Worker("my_task.js");\n\n// my_task.js中的代码 \nvar i = 0;\nfunction timedCount(){\n    i = i+1;\n    postMessage(i);\n    setTimeout(timedCount, 1000);\n}\ntimedCount();\n')])])]),a("h2",{attrs:{id:"数据通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据通信"}},[r._v("#")]),r._v(" 数据通信")]),r._v(" "),a("p",[r._v("当实例运行了一个 Worker 线程之后，两个线程是运行在完全独立的环境中，他们之间的通信是通过基于事件监听机制的 message 来实现的，"),a("code",[r._v("new Worker()")]),r._v(" 之后会返回一个实例对象，它包含一个 "),a("code",[r._v("postMessage")]),r._v(" 方法，可以通过调用这个方法来给 Worker 线程传递信息；同时我们可以给这个对象监听事件，这样，就能在 Worker 中触发事件通信的时候接收到数据了\n在 Worker 的脚本中，我们可以调用全局函数 "),a("code",[r._v("postMessage")]),r._v(" 和给全局的 "),a("code",[r._v("onmessage")]),r._v(" 赋值来发送和监听数据和事件：")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("// worker.js\nconsole.log('WORKER TASK: ', 'running');```\n// 监听事件\nonmessage = function (e) {\n  console.log('WORKER TASK: ', 'RECEIVE', e.data);\n  // 发送数据事件\n  postMessage('Hello, I am Worker');\n}\n")])])]),a("h2",{attrs:{id:"worker-的环境与作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker-的环境与作用域"}},[r._v("#")]),r._v(" Worker 的环境与作用域")]),r._v(" "),a("p",[r._v("在 Worker 线程的运行环境中没有 window 全局对象，也无法访问 DOM 对象，所以一般来说他只能来执行纯 JavaScript 的计算操作。")]),r._v(" "),a("h2",{attrs:{id:"sharedworker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sharedworker"}},[r._v("#")]),r._v(" SharedWorker")]),r._v(" "),a("p",[r._v("对于 Web Worker ，一个 tab 页面只能对应一个 Worker 线程，是相互独立的；"),a("br"),r._v("\n而 SharedWorker 提供了能力能够让不同标签中页面共享的同一个 Worker 脚本线程；"),a("br"),r._v("\n当然，有个很重要的限制就是它们需要满足同源策略，也就是需要在同域下；"),a("br"),r._v("\n在 SharedWorker 的使用中，我们发现对于 SharedWorker 实例对象，我们需要通过 port 属性来访问到主要方法；")]),r._v(" "),a("h2",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[r._v("#")]),r._v(" 优点")]),r._v(" "),a("p",[r._v("Web Worker 的实现为前端程序带来了后台计算的能力，可以实现主 UI 线程与复杂计运算线程的分离，从而极大减轻了因计算量大而造成 UI 阻塞而出现的界面渲染卡、掉帧的情况，并且更大程度地利用了终端硬件的性能；\n同时把程序之间的任务更清晰、条理化；")]),r._v(" "),a("h2",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[r._v("#")]),r._v(" 应用场景：")]),r._v(" "),a("ul",[a("li",[r._v("对于图像、视频、音频的解析处理；")]),r._v(" "),a("li",[r._v("canvas 中的图像计算处理；")]),r._v(" "),a("li",[r._v("大量的 ajax 请求或者网络服务轮询；")]),r._v(" "),a("li",[r._v("大量数据的计算处理（排序、检索、过滤、分析...）；")])])])}),[],!1,null,null,null);e.default=s.exports}}]);