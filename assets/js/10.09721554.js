(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{496:function(t,n,e){"use strict";e.r(n);var s=e(4),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),e("ol",[e("li",[t._v("看作图。把一些问题抽象成图，从一个点开始，向四周开始扩散。")]),t._v(" "),e("li",[t._v("使用队列。一般来说，写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。")]),t._v(" "),e("li",[t._v("空间复杂度大。BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) {\n    Queue<Node> q; // 核心数据结构\n    Set<Node> visited; // 避免走回头路\n\n    q.offer(start); // 将起点加入队列\n    visited.add(start);\n    int step = 0; // 记录扩散的步数\n\n    while (q not empty) {\n        int sz = q.size();\n        /* 将当前队列中的所有节点向四周扩散 */\n        for (int i = 0; i < sz; i++) {\n            Node cur = q.poll();\n            /* 划重点：这里判断是否到达终点 */\n            if (cur is target)\n                return step;\n            /* 将 cur 的相邻节点加入队列 */\n            for (Node x : cur.adj())\n                if (x not in visited) {\n                    q.offer(x);\n                    visited.add(x);\n                }\n        }\n        /* 划重点：更新步数在这里 */\n        step++;\n    }\n}\n")])])]),e("h3",{attrs:{id:"_1、为什么-bfs-可以找到最短距离-dfs-不行吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、为什么-bfs-可以找到最短距离-dfs-不行吗"}},[t._v("#")]),t._v(" 1、为什么 BFS 可以找到最短距离，DFS 不行吗?")]),t._v(" "),e("p",[t._v("首先，你看 BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。\nDFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。\n形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。")])])}),[],!1,null,null,null);n.default=a.exports}}]);