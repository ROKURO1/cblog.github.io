(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{523:function(t,a,s){"use strict";s.r(a);var e=s(4),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[t._v("#")]),t._v(" 源码")]),t._v(" "),s("h2",{attrs:{id:"双向绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[t._v("#")]),t._v(" 双向绑定")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("基于数据劫持&发布订阅模式")])])]),t._v(" "),s("ol",[s("li",[t._v("通过Object.defineProperty()来劫持各个属性的set，get，监听数据变化\n"),s("ul",[s("li",[t._v("get:依赖收集（收集依赖于此变量的组件 dep.depend())")]),t._v(" "),s("li",[t._v("set:在数据变更时通知订阅者更新视图 dep.notify()")])])]),t._v(" "),s("li",[t._v("Dep发布者 用来收集/删除/向依赖发送消息")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("class Dep{\n    constructor(){\n        this.subs = []\n    }\n    addSub(sub){\n        this.subs.push(sub)\n    }\n    notify(){\n        this.subs.forEach((sub)=>{sub.update()})\n    }\n}\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("Watcher 订阅者")])]),t._v(" "),s("ul",[s("li",[t._v("上面提到的依赖收集是将watcher对象放到subs中，watcher就是各种依赖的一个封装好的类的实例")]),t._v(" "),s("li",[t._v("根据Compile提供的指令进行视图渲染，触发相应的监听回调，更新视图。")])]),t._v(" "),s("h2",{attrs:{id:"虚拟dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),s("ol",[s("li",[t._v("VNode\n调用render()生成虚拟DOM，VNode是其中每一个节点的抽象，包含："),s("br"),t._v("\na.标签tag b.属性props c.子节点children")]),t._v(" "),s("li",[t._v("初次渲染 VDOM转换为真实DOM。update()")]),t._v(" "),s("li",[t._v("再次渲染 diff对比新旧虚拟DOM 返回一个patches，从而将变化的部分更新到视图。")])]),t._v(" "),s("h2",{attrs:{id:"模版编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模版编译"}},[t._v("#")]),t._v(" 模版编译")]),t._v(" "),s("ul",[s("li",[t._v("第一步是将 模板字符串 转换成 element ASTs（解析器）")]),t._v(" "),s("li",[t._v("第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）")]),t._v(" "),s("li",[t._v("第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）'")])]),t._v(" "),s("h3",{attrs:{id:"一、解析器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、解析器"}},[t._v("#")]),t._v(" 一、解析器")]),t._v(" "),s("p",[t._v("将")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<div>\n  <p>{{name}}</p>\n</div>\n")])])]),s("p",[t._v("转化为")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('{\n  tag: "div"\n  type: 1,\n  staticRoot: false,\n  static: false,\n  plain: true,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n      {\n      tag: "p"\n      type: 1,\n      staticRoot: false,\n      static: false,\n      plain: true,\n      parent: {tag: "div", ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n          type: 2,\n          text: "{{name}}",\n          static: false,\n          expression: "_s(name)"\n      }]\n    }\n  ]\n}\n')])])]),s("ol",[s("li",[t._v("用正则 解析开始标签 中包含的数据（attrs, tagName 等）。")]),t._v(" "),s("li",[t._v("就是要维护一个 stack 记录一个层级关系的，用来记录DOM的深度。")])]),t._v(" "),s("h3",{attrs:{id:"优化器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[t._v("#")]),t._v(" 优化器")]),t._v(" "),s("p",[t._v("优化器的目标是找出那些静态节点并打上标记，而静态节点指的是 DOM 不需要发生变化的节点"),s("br"),t._v("\n例如"),s("code",[t._v("<p>我是静态节点，我不需要发生变化</p>")]),s("br"),t._v("\n标记静态节点有两个好处：")]),t._v(" "),s("ul",[s("li",[t._v("每次重新渲染的时候不需要为静态节点创建新节点")]),t._v(" "),s("li",[t._v("在 Virtual DOM 中 patching 的过程可以被跳过")])])])}),[],!1,null,null,null);a.default=n.exports}}]);