(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{503:function(a,t,s){"use strict";s.r(t);var r=s(4),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[a._v("#")]),a._v(" 设计模式")]),a._v(" "),s("h2",{attrs:{id:"一、工厂模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、工厂模式"}},[a._v("#")]),a._v(" 一、工厂模式")]),a._v(" "),s("h3",{attrs:{id:"设计思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计思想"}},[a._v("#")]),a._v(" 设计思想")]),a._v(" "),s("ul",[s("li",[a._v("将 new 操作单独封装，只对外提供相应接口；")]),a._v(" "),s("li",[a._v("遇到new 时，就要考虑是否应该使用工厂模式；")])]),a._v(" "),s("h3",{attrs:{id:"核心作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心作用"}},[a._v("#")]),a._v(" 核心作用")]),a._v(" "),s("ul",[s("li",[a._v("主要用于隐藏创建实例的复杂度，只需对外提供一个接口；")]),a._v(" "),s("li",[a._v("实现构造函数和创建者的分离，满足开放封闭的原则；"),s("br"),a._v(" "),s("strong",[a._v("简单工厂模式：一个工厂对象创建一种产品对象实例。即用来创建同一类对象")])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 定义产品\nclass Product {\n    constructor(name) {\n        this.name = name;\n    }\n    init() {\n        console.log('初始化产品')\n    }\n}\n\n// 定义工厂\nclass Factory {\n    create(name) {\n        return new Product(name); // 核心思想\n    }\n}\n\nlet c = new Factory(); \nlet p = c.create('p1');\np.init();\n\n")])])]),s("h2",{attrs:{id:"二、单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、单例模式"}},[a._v("#")]),a._v(" 二、单例模式")]),a._v(" "),s("p",[s("strong",[a._v("保证一个类仅有一个实例，并提供一个访问它的全局访问点 。")])]),a._v(" "),s("h3",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[a._v("#")]),a._v(" 应用场景")]),a._v(" "),s("p",[a._v("弹窗、购物车、Vuex")]),a._v(" "),s("h3",{attrs:{id:"代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[a._v("#")]),a._v(" 代码")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("class Modal {\n    login() {\n        console.log('login...');\n    }\n}\nModal.create = (function() {\n    let instance\n    return function() {\n        if(!instance) {\n           instance = new Modal();\n        }\n        return instance\n    }\n})()\nlet m1 = Modal.create();\nlet m2 = Modal.create();\nconsole.log(m1 === m2) // true\n\n")])])]),s("h2",{attrs:{id:"三、适配器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、适配器模式"}},[a._v("#")]),a._v(" 三、适配器模式")]),a._v(" "),s("h3",{attrs:{id:"特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("将一个类（对象）的接口（方法或属性）转化成适应当前场景的另一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。所以，适配器模式必须包含目标（Target）、源（Adaptee）和适配器（Adapter）三个角色。")]),a._v(" "),s("h2",{attrs:{id:"四、装饰器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、装饰器模式"}},[a._v("#")]),a._v(" 四、装饰器模式")]),a._v(" "),s("h3",{attrs:{id:"特征-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征-2"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("在原来方法的基础上去装饰一些针对特别场景所适用的方法，即添加一些新功能。因此其特征主要有两点：")]),a._v(" "),s("ul",[s("li",[a._v("为对象添加新功能；")]),a._v(" "),s("li",[a._v("不改变其原有的结构和功能，即原有功能还继续会用，且场景不会改变。")])]),a._v(" "),s("h3",{attrs:{id:"装饰器插件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器插件"}},[a._v("#")]),a._v(" 装饰器插件")]),a._v(" "),s("h3",{attrs:{id:"场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[a._v("#")]),a._v(" 场景")]),a._v(" "),s("h2",{attrs:{id:"五、代理模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、代理模式"}},[a._v("#")]),a._v(" 五、代理模式")]),a._v(" "),s("h3",{attrs:{id:"特征-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特征-3"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),s("p",[a._v("该模式场景需要三类角色，分别为使用者、目标对象和代理者，使用者的目的是直接访问目标对象，但却不能直接访问，而是要先通过代理者。因此该模式非常像明星代理人的场景。其特征为：")]),a._v(" "),s("ul",[s("li",[a._v("使用者无权访问目标对象；")]),a._v(" "),s("li",[a._v("中间加代理，通过代理做授权和控制。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);