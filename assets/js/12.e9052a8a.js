(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{497:function(e,a,t){"use strict";t.r(a);var n=t(4),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[e._v("#")]),e._v(" 链表")]),e._v(" "),t("p",[t("em",[t("strong",[e._v("链表 训练递归思维")])])]),e._v(" "),t("h2",{attrs:{id:"递归反转整个链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#递归反转整个链表"}},[e._v("#")]),e._v(" 递归反转整个链表")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function reverse(head){\n    if(head.next === null)return head\n    let last = reverse(head.next);\n    head.next.next = head;\n    head.next = null;\n    return last;\n}\n")])])]),t("p",[e._v("对于递归算法，最重要的就是明确递归函数的定义。具体来说，我们的 reverse 函数定义是这样的：\n输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。"),t("br"),e._v("\n不要深入去想递归的过程，先考虑一个节点")]),e._v(" "),t("h2",{attrs:{id:"反转链表前n个节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#反转链表前n个节点"}},[e._v("#")]),e._v(" 反转链表前N个节点")]),e._v(" "),t("h2",{attrs:{id:"删除链表节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除链表节点"}},[e._v("#")]),e._v(" 删除链表节点")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var deleteNode = function(head, val) {\n    if(head===null)return null //到链表的最后一个元素\n    if(head.val == val){\n        return head.next //此时符合条件，将这个要被删除节点的下一个节点返回\n    }\n    head.next = deleteNode(head.next,val)//下一个节点是递归下一个节点的返回值\n    return head //返回最初的起点\n};\n")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);