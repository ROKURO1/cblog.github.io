(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{515:function(t,s,a){"use strict";a.r(s);var r=a(4),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("h2",{attrs:{id:"网络传输性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能"}},[t._v("#")]),t._v(" 网络传输性能")]),t._v(" "),a("ol",[a("li",[t._v("减少请求数量 浏览器缓存、图片懒加载、使用雪碧图（CSS Sprite）")]),t._v(" "),a("li",[t._v("减少请求体积 Webpack")]),t._v(" "),a("li",[t._v("提升网络传输 CDN")])]),t._v(" "),a("h2",{attrs:{id:"css优化-页面渲染性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css优化-页面渲染性能"}},[t._v("#")]),t._v(" CSS优化（页面渲染性能）")]),t._v(" "),a("p",[t._v("css文件引入放置在HTML head头部，因为css的加载、解析并不会阻塞DOM解析，提前加载可以更快合成Render树"),a("br"),t._v("\n（不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，尽可能少地触发重新渲染。正如我们在2.3中提到的，重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。）")]),t._v(" "),a("h2",{attrs:{id:"js阻塞性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js阻塞性能"}},[t._v("#")]),t._v(" JS阻塞性能")]),t._v(" "),a("ol",[a("li",[t._v("Web Worker")]),t._v(" "),a("li",[t._v("节流/防抖")]),t._v(" "),a("li",[t._v("js文件引入放置在HTML body尾部，因为js的加载、执行会阻塞页面渲染")]),t._v(" "),a("li",[t._v("事件委托")])])])}),[],!1,null,null,null);s.default=e.exports}}]);