(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{507:function(t,a,r){"use strict";r.r(a);var s=r(4),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"es6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6")]),t._v(" "),r("h2",{attrs:{id:"let-const"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#let-const"}},[t._v("#")]),t._v(" let&const")]),t._v(" "),r("ol",[r("li",[t._v("块级作用域")]),t._v(" "),r("li",[t._v("没有变量提升")]),t._v(" "),r("li",[t._v("暂时性死区：在声明之前使用变量会报错")]),t._v(" "),r("li",[t._v("不可以重复声明")])]),t._v(" "),r("h2",{attrs:{id:"函数的扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数的扩展"}},[t._v("#")]),t._v(" 函数的扩展")]),t._v(" "),r("ol",[r("li",[t._v("函数参数的默认值")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function log(x, y = 'World') {\n  console.log(x, y);\n}\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("rest参数\n用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function add(...values) {\n  let sum = 0;\n  for (var val of values) {\n    sum += val;\n  }\n  return sum;\n}\nadd(2, 5, 3) // 10\n")])])]),r("ol",{attrs:{start:"3"}},[r("li",[t._v("name\n函数的name属性，返回该函数的函数名。")]),t._v(" "),r("li",[t._v("箭头函数\n（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。"),r("br"),t._v("\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。"),r("br"),t._v("\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。"),r("br"),t._v("\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。"),r("br")])]),t._v(" "),r("h2",{attrs:{id:"数组的扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组的扩展"}},[t._v("#")]),t._v(" 数组的扩展")]),t._v(" "),r("h3",{attrs:{id:"_1、扩展运算符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、扩展运算符"}},[t._v("#")]),t._v(" 1、扩展运算符")]),t._v(" "),r("p",[t._v("它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n")])])]),r("h3",{attrs:{id:"_2、array-from"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、array-from"}},[t._v("#")]),t._v(" 2、Array.from()")]),t._v(" "),r("p",[t._v("两类对象转为真正的数组：")]),t._v(" "),r("ol",[r("li",[t._v("类似数组的对象（array-like object）")]),t._v(" "),r("li",[t._v("可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。")])]),t._v(" "),r("h3",{attrs:{id:"_3、array-of"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、array-of"}},[t._v("#")]),t._v(" 3、Array.of()")]),t._v(" "),r("p",[r("code",[t._v("Array.of(3, 11, 8) // [3,11,8]")])]),t._v(" "),r("h3",{attrs:{id:"_4、copywithin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、copywithin"}},[t._v("#")]),t._v(" 4、copyWithin()")]),t._v(" "),r("p",[t._v("copyWithin(被覆盖起始位置，选取的数据起始位置，选取额数据结束位置)"),r("br"),t._v(" "),r("code",[t._v("[1,2,3,4,5].copyWithin(0,2,4) //被截取数据位置为[2,4）---[3,4],替换起始位置是0，所以结果是[3,4,3,4,5]")])]),t._v(" "),r("h3",{attrs:{id:"_5、find-规则-、findindex-规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、find-规则-、findindex-规则"}},[t._v("#")]),t._v(" 5、find(规则)、findIndex(规则)")]),t._v(" "),r("p",[r("code",[t._v("[9,8,7,6,5,4,3].find(n=>n<5) //返回4")])]),t._v(" "),r("h3",{attrs:{id:"_6、fill-被填充数据-起始位置-结束位置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、fill-被填充数据-起始位置-结束位置"}},[t._v("#")]),t._v(" 6、fill(被填充数据，起始位置，结束位置)")]),t._v(" "),r("p",[r("code",[t._v("[2,2,2,2,2,2].fill(8,2,4) //将8覆盖原[2,4)位置上的数据，[2,2,8,8,2,2]")])]),t._v(" "),r("h2",{attrs:{id:"对象的扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的扩展"}},[t._v("#")]),t._v(" 对象的扩展")]),t._v(" "),r("ol",[r("li",[t._v("对象里面可以直接写入变量和函数")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//before：\nvar person = {\n    name:'eco',\n    age:18,\n    say:function(something){\n        console.log(\"hello \"+something);\n    }\n};\nperson.say('world');\n\n//now:\nvar firstname='jack';\nvar man = {\n    firstname,\n    say(something){\n        console.log(this.firstname);\n        console.log(\"hello \"+something);\n    }\n};\nman.say('world');\n")])])]),r("ol",{attrs:{start:"2"}},[r("li",[t._v("Object.is(值1，值2)用于比较两个值是否相等，返回布尔值")]),t._v(" "),r("li",[t._v("Object.assign(targetobject,sourceobject1,sourceobject2)")])]),t._v(" "),r("ul",[r("li",[t._v("用于对象的合并，将源对象合并到目标对象，若有相同属性源对象属性覆盖目标对象属性")]),t._v(" "),r("li",[t._v("如果源对象是其他数据类型，只有字符串会以字符数组形式拷到目标对象，其他类型不会有效果")])]),t._v(" "),r("h2",{attrs:{id:"module"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[t._v("#")]),t._v(" Module")]),t._v(" "),r("p",[t._v("ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。")]),t._v(" "),r("h3",{attrs:{id:"特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点：")]),t._v(" "),r("ul",[r("li",[t._v("编译时加载")]),t._v(" "),r("li",[t._v("本身不是对象（CommonJS是对象）")])]),t._v(" "),r("h3",{attrs:{id:"_1-export命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-export命令"}},[t._v("#")]),t._v(" 1. export命令")]),t._v(" "),r("p",[t._v("输出变量、函数、类")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("export function multiply(x, y) {\n  return x * y;\n};\n")])])]),r("p",[t._v("通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n\n// 报错\nfunction f() {}\nexport f;\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n")])])]),r("h3",{attrs:{id:"_2-import"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-import"}},[t._v("#")]),t._v(" 2.import")]),t._v(" "),r("p",[t._v("import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。\n"),r("br"),t._v("\n如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。\n"),r("code",[t._v("import { lastName as surname } from './profile.js';")])]),t._v(" "),r("h4",{attrs:{id:"特点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),r("ol",[r("li",[t._v("import具有提升效果 会提升到整个模块的头部，首先执行。（因为Module编译时加载")])]),t._v(" "),r("h3",{attrs:{id:"_3-模块的整体加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-模块的整体加载"}},[t._v("#")]),t._v(" 3.模块的整体加载")]),t._v(" "),r("p",[t._v("星号（*）指定一个对象，所有输出值都加载在这个对象上面。")]),t._v(" "),r("h3",{attrs:{id:"_4-export-default-命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-export-default-命令"}},[t._v("#")]),t._v(" 4.export default 命令")]),t._v(" "),r("p",[t._v("export default命令，为模块指定默认输出;其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。"),r("br"),t._v("\nexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。")]),t._v(" "),r("h3",{attrs:{id:"浏览器加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器加载"}},[t._v("#")]),t._v(" 浏览器加载")]),t._v(" "),r("p",[t._v("HTML 网页中，浏览器通过script标签加载 JavaScript 脚本。"),r("br"),t._v("\n默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。"),r("br"),t._v("\n如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。"),r("br")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('<script src="path/to/myModule.js" defer><\/script>\n<script src="path/to/myModule.js" async><\/script>\n')])])]),r("p",[t._v("上面代码中，script标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。"),r("br"),t._v(" "),r("em",[r("strong",[t._v("defer与async的区别是")])]),t._v("：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。"),r("br")]),t._v(" "),r("h4",{attrs:{id:"加载-es6-模块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#加载-es6-模块"}},[t._v("#")]),t._v(" 加载 ES6 模块")]),t._v(" "),r("p",[t._v('浏览器加载 ES6 模块，也使用script标签，但是要加入type="module"属性。'),r("br"),t._v(" "),r("code",[t._v('<script type="module" src="./foo.js"><\/script>')]),t._v("\n上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。"),r("br"),t._v('\n浏览器对于带有type="module"的script，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script标签的defer属性。'),r("br"),t._v('\n如果网页有多个script type="module"，它们会按照在页面出现的顺序依次执行。'),r("br"),t._v("\nscript 标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。"),r("br")]),t._v(" "),r("h3",{attrs:{id:"es6-模块与-commonjs-模块的差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块与-commonjs-模块的差异"}},[t._v("#")]),t._v(" ES6 模块与 CommonJS 模块的差异")]),t._v(" "),r("p",[t._v("三个重大差异：")]),t._v(" "),r("ol",[r("li",[t._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")]),t._v(" "),r("li",[t._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")]),t._v(" "),r("li",[t._v("CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);